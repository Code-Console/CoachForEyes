<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>STL viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!--
        Require to update post and pre Treatment stl file
        file should be ne stl formate
    -->
    <script>
      const postMandibularUrl = "./assets/PostTreatment_Mandibular.stl";
      const postMaxillaryUrl = "./assets/PostTreatment_Maxillary.stl";
      const preMandibularUrl = "./assets/PreTreatment_Mandibular.stl";
      const preMaxillaryUrl = "./assets/PreTreatment_Maxillary.stl";
      const envHDRUrl = "./assets/env.hdr";
    </script>
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/RGBELoader.js"></script>
    <style>
      body {
        margin: 0;
        background: #424242;
      }

      #c {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
      }

      .ui-container {
        display: flex;
        flex-direction: row;
        text-align: center;
      }

      .selected {
        background: radial-gradient(
          circle,
          rgb(244, 205, 250) 0%,
          rgba(182, 157, 211, 1) 100%
        );
      }

      .unselected {
        background: radial-gradient(
          circle,
          rgba(175, 175, 175, 1) 0%,
          rgba(125, 125, 125, 1) 100%
        );
      }

      .ui-child {
        width: 48%;
        height: 50px;

        margin: 0 1%;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
      }

      .loader {
        border: 16px solid #f3f3f3;
        /* Light grey */
        border-top: 16px solid #3498db;
        /* Blue */
        border-radius: 50%;
        width: 120px;
        height: 120px;
        position: fixed;
        left: calc(50% - 120px);
        top: calc(50% - 120px);
        animation: spin 2s linear infinite;
      }

      .progress {
        position: fixed;
        left: calc(50% - 60px);
        top: calc(50% - 50px);
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body>
    <canvas id="c"></canvas>
    <div class="ui-container">
      <div
        id="pre-child"
        class="ui-child selected"
        onclick="handleClick('pre-child',event)"
      >
        <div style="margin-top: 5px">Pre Treatment</div>
        <div class="sub-child">
          Mandibular
          <input
            type="checkbox"
            id="preMandibular"
            name="preMandibular"
            value="preMandibular"
            checked
            onchange="handleClick('preMandibular')"
            disabled
          />
          Maxillary
          <input
            type="checkbox"
            id="preMaxillary"
            name="preMaxillary"
            value="preMaxillary"
            checked
            onchange="handleClick('preMaxillary')"
            disabled
          />
        </div>
      </div>
      <div
        id="post-child"
        class="ui-child unselected"
        onclick="handleClick('post-child',event)"
      >
        <div style="margin-top: 5px">Post Treatment</div>
        <div class="sub-child">
          Mandibular
          <input
            type="checkbox"
            id="postMandibular"
            name="postMandibular"
            value="postMandibular"
            onchange="handleClick('postMandibular')"
            disabled
          />
          Maxillary
          <input
            type="checkbox"
            id="postMaxillary"
            name="postMaxillary"
            value="postMaxillary"
            onchange="handleClick('postMaxillary')"
            disabled
          />
        </div>
      </div>
    </div>

    <div id="loader" class="loader"></div>
    <div id="progress" class="progress">0%</div>

    <script>
      let isObjectsLoaded = false;
      let preMandibularMesh;
      let preMaxillaryMesh;
      let postMandibularMesh;
      let postMaxillaryMesh;
      const frustumSize = 500;
      const canvas = document.querySelector("#c");
      const modelScale = 3;
      const loadModel = () => {
        document.getElementById("loader").style.display = "none";
        document.getElementById("progress").style.display = "none";
        document.querySelector("#preMandibular").disabled = false;
        document.querySelector("#preMaxillary").disabled = false;
        document.querySelector("#postMandibular").disabled = false;
        document.querySelector("#postMaxillary").disabled = false;
        isObjectsLoaded = true;
      };
      const manager = new THREE.LoadingManager(loadModel);
      manager.onProgress = (item, loaded, total) => {
        document.getElementById("progress").innerHTML =
          (loaded / total) * 100 + "%";
      };
      const setTab = (ele, e) => {
        if (ele.includes("post")) {
          document.getElementById("pre-child").classList.remove("selected");
          document.getElementById("pre-child").classList.add("unselected");

          document.getElementById("post-child").classList.add("selected");
          document.getElementById("post-child").classList.remove("unselected");

          document.querySelector("#preMandibular").checked = false;
          document.querySelector("#preMaxillary").checked = false;
        } else {
          document.getElementById("post-child").classList.remove("selected");
          document.getElementById("post-child").classList.add("unselected");

          document.getElementById("pre-child").classList.add("selected");
          document.getElementById("pre-child").classList.remove("unselected");

          document.querySelector("#postMandibular").checked = false;
          document.querySelector("#postMaxillary").checked = false;
        }
        if (event.target.defaultValue) return;
        if (ele.includes("pre-child")) {
          document.querySelector("#preMandibular").checked = true;
          document.querySelector("#preMaxillary").checked = true;
        }
        if (ele.includes("post-child")) {
          document.querySelector("#postMandibular").checked = true;
          document.querySelector("#postMaxillary").checked = true;
        }
      };
      const handleClick = (ele, e) => {
        if (!isObjectsLoaded) return;
        setTab(ele, e);
        if (ele.includes("post")) {
          document.querySelector("#preMandibular").checked = false;
          document.querySelector("#preMaxillary").checked = false;
        } else {
          document.querySelector("#postMandibular").checked = false;
          document.querySelector("#postMaxillary").checked = false;
        }
        const preMandibular = document.querySelector("#preMandibular").checked;
        const preMaxillary = document.querySelector("#preMaxillary").checked;
        const postMandibular =
          document.querySelector("#postMandibular").checked;
        const postMaxillary = document.querySelector("#postMaxillary").checked;

        if (preMandibularMesh) preMandibularMesh.visible = preMandibular;
        if (preMaxillaryMesh) preMaxillaryMesh.visible = preMaxillary;
        if (postMandibularMesh) postMandibularMesh.visible = postMandibular;
        if (postMaxillaryMesh) postMaxillaryMesh.visible = postMaxillary;
      };

      window.onload = () => {
        init();
      };
      const init = () => {
        const width = window.innerWidth,
          height = window.innerHeight;
        const scene = new THREE.Scene();
        // const camera = new THREE.PerspectiveCamera(width/ height,0.1,1000);
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(
          (frustumSize * aspect) / -2,
          (frustumSize * aspect) / 2,
          frustumSize / 2,
          frustumSize / -2,
          1,
          1000
        );

        const renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true,
          alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x424242, 1);
        renderer.outputEncoding = THREE.sRGBEncoding;

        function addShadowedLight(x, y, z, color, intensity) {
          const directionalLight = new THREE.DirectionalLight(color, intensity);
          directionalLight.position.set(x, y, z);
          scene.add(directionalLight);
          directionalLight.castShadow = true;
          const d = 1;
          directionalLight.shadow.camera.left = -d;
          directionalLight.shadow.camera.right = d;
          directionalLight.shadow.camera.top = d;
          directionalLight.shadow.camera.bottom = -d;
          directionalLight.shadow.camera.near = 1;
          directionalLight.shadow.camera.far = 4;
          directionalLight.shadow.bias = -0.002;
        }
        const onWindowResize = () => {
          //   camera.aspect = aspect;
          //   camera.updateProjectionMatrix();
          //   renderer.setSize(window.innerWidth, window.innerHeight);

          const aspect = window.innerWidth / window.innerHeight;
          camera.left = (-frustumSize * aspect) / 2;
          camera.right = (frustumSize * aspect) / 2;
          camera.top = frustumSize / 2;
          camera.bottom = -frustumSize / 2;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        };
        window.addEventListener("resize", onWindowResize, false);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;

        controls.update();
        camera.position.set(0, 1, 500);
        const rgbeLoader = new THREE.RGBELoader();
        rgbeLoader.load(
          envHDRUrl,
          (texture) => {
            if (renderer && scene) {
              let pmremGenerator = new THREE.PMREMGenerator(renderer);
              pmremGenerator.compileEquirectangularShader();
              const envMap =
                pmremGenerator.fromEquirectangular(texture).texture;
              pmremGenerator = undefined;
              scene.environment = envMap;
            }
          },
          undefined,
          undefined
        );
        const loader = new THREE.STLLoader(manager);
        loader.load(postMandibularUrl, function (geometry) {
          const material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            specular: 0x111111,

            flatShading: true,
            smoothShading: true,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.scale.set(modelScale, modelScale, modelScale);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          postMandibularMesh = mesh;
          postMandibularMesh.visible = false;
        });
        loader.load(postMaxillaryUrl, function (geometry) {
          const material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            specular: 0x111111,

            flatShading: true,
            smoothShading: true,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.scale.set(modelScale, modelScale, modelScale);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          postMaxillaryMesh = mesh;
          postMaxillaryMesh.visible = false;
        });
        loader.load(preMandibularUrl, function (geometry) {
          const material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            specular: 0x111111,

            flatShading: true,
            smoothShading: true,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.scale.set(modelScale, modelScale, modelScale);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          preMandibularMesh = mesh;
        });
        loader.load(preMaxillaryUrl, function (geometry) {
          const material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            specular: 0x111111,

            flatShading: true,
            smoothShading: true,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.scale.set(modelScale, modelScale, modelScale);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          preMaxillaryMesh = mesh;
        });

        addShadowedLight(0, 0, 10, 0xffffff, 0.5);
        addShadowedLight(0, 0, -10, 0xffffff, 0.5);
        const light = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(light);
        let counter = 0;

        const animate = () => {
          counter += 1;
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
          controls.update();
        };
        animate();
      };
    </script>
  </body>
</html>
